/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef file_dragger_TYPES_H
#define file_dragger_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace file_dragger {

class FileInfo;

class RequestQuery;

class ResponseQuery;

class RequestDownload;

class ResponseDownload;

class RequestFinish;

class ResponseFinish;

typedef struct _FileInfo__isset {
  _FileInfo__isset() : rpath(false), isDir(false) {}
  bool rpath :1;
  bool isDir :1;
} _FileInfo__isset;

class FileInfo {
 public:

  FileInfo(const FileInfo&);
  FileInfo& operator=(const FileInfo&);
  FileInfo() : rpath(), isDir(0) {
  }

  virtual ~FileInfo() throw();
  std::string rpath;
  bool isDir;

  _FileInfo__isset __isset;

  void __set_rpath(const std::string& val);

  void __set_isDir(const bool val);

  bool operator == (const FileInfo & rhs) const
  {
    if (!(rpath == rhs.rpath))
      return false;
    if (!(isDir == rhs.isDir))
      return false;
    return true;
  }
  bool operator != (const FileInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FileInfo &a, FileInfo &b);

inline std::ostream& operator<<(std::ostream& out, const FileInfo& obj)
{
  obj.printTo(out);
  return out;
}


class RequestQuery {
 public:

  RequestQuery(const RequestQuery&);
  RequestQuery& operator=(const RequestQuery&);
  RequestQuery() {
  }

  virtual ~RequestQuery() throw();

  bool operator == (const RequestQuery & /* rhs */) const
  {
    return true;
  }
  bool operator != (const RequestQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RequestQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RequestQuery &a, RequestQuery &b);

inline std::ostream& operator<<(std::ostream& out, const RequestQuery& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ResponseQuery__isset {
  _ResponseQuery__isset() : has_new_file_dir(false), file_dir_info(false) {}
  bool has_new_file_dir :1;
  bool file_dir_info :1;
} _ResponseQuery__isset;

class ResponseQuery {
 public:

  ResponseQuery(const ResponseQuery&);
  ResponseQuery& operator=(const ResponseQuery&);
  ResponseQuery() : has_new_file_dir(0) {
  }

  virtual ~ResponseQuery() throw();
  bool has_new_file_dir;
  std::vector<FileInfo>  file_dir_info;

  _ResponseQuery__isset __isset;

  void __set_has_new_file_dir(const bool val);

  void __set_file_dir_info(const std::vector<FileInfo> & val);

  bool operator == (const ResponseQuery & rhs) const
  {
    if (!(has_new_file_dir == rhs.has_new_file_dir))
      return false;
    if (!(file_dir_info == rhs.file_dir_info))
      return false;
    return true;
  }
  bool operator != (const ResponseQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResponseQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResponseQuery &a, ResponseQuery &b);

inline std::ostream& operator<<(std::ostream& out, const ResponseQuery& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RequestDownload__isset {
  _RequestDownload__isset() : chunk(false), num_chunk(false), file_rpaths(false) {}
  bool chunk :1;
  bool num_chunk :1;
  bool file_rpaths :1;
} _RequestDownload__isset;

class RequestDownload {
 public:

  RequestDownload(const RequestDownload&);
  RequestDownload& operator=(const RequestDownload&);
  RequestDownload() : chunk(0), num_chunk(0) {
  }

  virtual ~RequestDownload() throw();
  int32_t chunk;
  int32_t num_chunk;
  std::vector<std::string>  file_rpaths;

  _RequestDownload__isset __isset;

  void __set_chunk(const int32_t val);

  void __set_num_chunk(const int32_t val);

  void __set_file_rpaths(const std::vector<std::string> & val);

  bool operator == (const RequestDownload & rhs) const
  {
    if (!(chunk == rhs.chunk))
      return false;
    if (!(num_chunk == rhs.num_chunk))
      return false;
    if (!(file_rpaths == rhs.file_rpaths))
      return false;
    return true;
  }
  bool operator != (const RequestDownload &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RequestDownload & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RequestDownload &a, RequestDownload &b);

inline std::ostream& operator<<(std::ostream& out, const RequestDownload& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ResponseDownload__isset {
  _ResponseDownload__isset() : chunk(false), files(false) {}
  bool chunk :1;
  bool files :1;
} _ResponseDownload__isset;

class ResponseDownload {
 public:

  ResponseDownload(const ResponseDownload&);
  ResponseDownload& operator=(const ResponseDownload&);
  ResponseDownload() : chunk(0) {
  }

  virtual ~ResponseDownload() throw();
  int32_t chunk;
  std::map<std::string, std::string>  files;

  _ResponseDownload__isset __isset;

  void __set_chunk(const int32_t val);

  void __set_files(const std::map<std::string, std::string> & val);

  bool operator == (const ResponseDownload & rhs) const
  {
    if (!(chunk == rhs.chunk))
      return false;
    if (!(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const ResponseDownload &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResponseDownload & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResponseDownload &a, ResponseDownload &b);

inline std::ostream& operator<<(std::ostream& out, const ResponseDownload& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RequestFinish__isset {
  _RequestFinish__isset() : file_dir_rpaths(false) {}
  bool file_dir_rpaths :1;
} _RequestFinish__isset;

class RequestFinish {
 public:

  RequestFinish(const RequestFinish&);
  RequestFinish& operator=(const RequestFinish&);
  RequestFinish() {
  }

  virtual ~RequestFinish() throw();
  std::vector<std::string>  file_dir_rpaths;

  _RequestFinish__isset __isset;

  void __set_file_dir_rpaths(const std::vector<std::string> & val);

  bool operator == (const RequestFinish & rhs) const
  {
    if (!(file_dir_rpaths == rhs.file_dir_rpaths))
      return false;
    return true;
  }
  bool operator != (const RequestFinish &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RequestFinish & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RequestFinish &a, RequestFinish &b);

inline std::ostream& operator<<(std::ostream& out, const RequestFinish& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ResponseFinish__isset {
  _ResponseFinish__isset() : num_handled(false) {}
  bool num_handled :1;
} _ResponseFinish__isset;

class ResponseFinish {
 public:

  ResponseFinish(const ResponseFinish&);
  ResponseFinish& operator=(const ResponseFinish&);
  ResponseFinish() : num_handled(0) {
  }

  virtual ~ResponseFinish() throw();
  int32_t num_handled;

  _ResponseFinish__isset __isset;

  void __set_num_handled(const int32_t val);

  bool operator == (const ResponseFinish & rhs) const
  {
    if (!(num_handled == rhs.num_handled))
      return false;
    return true;
  }
  bool operator != (const ResponseFinish &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResponseFinish & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResponseFinish &a, ResponseFinish &b);

inline std::ostream& operator<<(std::ostream& out, const ResponseFinish& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
